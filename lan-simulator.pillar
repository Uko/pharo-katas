! Designing a simple network simulation platform

- design from scratch
- nodes, links
- time simulation with ticks

The goal of this document is to show how we would develop from scratch in Pharo.
The program we are going to develop is a simple representation of a computer network.
At first, we will just simulate the different steps of packet delivery, but eventually, our program could be refined to become an experiment platform to explore and understand distributed algorithms.

!! Basic definitions and a starting point

We need to establish the basic model; what does the description above tell us?
A network is a number of interconnected nodes, which exchange data packets.
We will therefore probably need to model the nodes, the connection links, and the packets:

- Nodes have addresses, can send and receive packets;
- Links connect two nodes together, and transmit packets between them;
- Packets transport a payload and have the address of the node to which it should be delivered; if we want nodes to be able to answer, packets should also have the address of the node which originally sent it.

Let's start exploring by sketching some simple tests; this requires defining a test class:

[[[language=smalltalk
TestCase subclass: #KANetworkTest
    instanceVariableNames: ''
    classVariableNames: ''
    category: 'Kata-NetworkSimulator-Tests'
]]]


!!! Packets are simple value objects

Packets are the simplest objects in our model: we need to create them, and ask them about the data they contain, but that's about it.
Once created, a packet will not change its data, and the packet itself has no knowledge of the network, and no behavior that we can really talk about.

[[[language=smalltalk
KANetworkTest >> testPacketCreation
	| src dest payload packet |
	src := Object new.
	dest := Object new.
	payload := Object new.

	packet := KANetworkPacket from: src to: dest payload: payload.

	self assert: packet sourceAddress equals: src.
	self assert: packet destinationAddress equals: dest.
	self assert: packet payload equals: payload
]]]

In this unit test, we wrote how we think packets should be created, using a ==from:to:payload:== constructor message, and how it should be accessed, using three messages ==sourceAddress==, ==destinationAddress==, and ==payload==.
Since we have not yet decided what addresses and payloads should look like, we just pass arbitrary objects as parameters; all that matters is that when we ask the packet, it returns the correct object back.

Of course, if we now try to compile and run this test method, it will fail, because the class ==KANetworkPacket== has not been created yet, nor any of the four above messages; let's do that:

[[[language=smalltalk
KANetworkPacket >> Object subclass: #KANetworkPacket
	instanceVariableNames: 'sourceAddress destinationAddress payload'
	classVariableNames: ''
	category: 'Kata-NetworkSimulator-Core'
]]]

The class-side constructor method creates an instance then sends it an initialization message:

[[[language=smalltalk
KANetworkPacket class >> from: sourceAddress to: destinationAddress payload: anObject
	^ self new
		initializeSource: sourceAddress
		destination: destinationAddress
		payload: anObject
]]]

The initialization method is only supposed to be called when creating packets.

[[[language=smalltalk
KANetworkPacket >> initializeSource: source destination: destination payload: anObject
	sourceAddress := source.
	destinationAddress := destination.
	payload := anObject
]]]

Once a packet is created, all we need to do with it is to obtain its payload, or the addresses of its source or destination nodes.
We thus define an accessor method for each instance variable.

[[[language=smalltalk
KANetworkPacket >> sourceAddress
	^ sourceAddress
]]]

[[[language=smalltalk
KANetworkPacket >> destinationAddress
	^ destinationAddress
]]]

[[[language=smalltalk
KANetworkPacket >> payload
	^ payload
]]]

That's enough for our admittedly simplistic model of packets; we completely ignore the layers of the OSI model, but it could be an interesting exercise to model that more precisely.


!!! Nodes

The first obvious thing we can say about a network node is that if we want to be able to send packets to it, then it should have an address; let's translate that into a test:

[[[language=smalltalk
KANetworkTest >> testNodeCreation
	| address node |
	address := Object new.
	node := KANetworkNode withAddress: address.

	self assert: node address equals: address
]]]

Like before, before running this test, we have to define the ==KANetworkNode== class:

[[[language=smalltalk
Object subclass: #KANetworkNode
    instanceVariableNames: 'address'
    classVariableNames: ''
    category: 'Kata-NetworkSimulator-Core'
]]]

Then a class-side constructor method taking the address of the new node as parameter:

[[[language=smalltalk
KANetworkNode class >> withAddress: aNetworkAddress
	^ self new
		initializeAddress: aNetworkAddress;
		yourself
]]]

The constructor relies on an instance-side initialization method:

[[[language=smalltalk
KANetworkNode >> initializeAddress: aNetworkAddress
	address := aNetworkAddress
]]]

And we can ask a node for its address:

[[[language=smalltalk
KANetworkNode >> address
    ^ address
]]]


!!! Links are one-way connections between nodes

After nodes, we should look at links.
In the real world, a network cable is usually bidirectional, but here we're going to keep it simple and define links as simple one-way connections.
To make a two-way connection, we will just make two links, one in each direction.

Therefore, a link has a source and a destination node; additionally, to be able to send packets, nodes need to know about their outgoing links.

[[[language=smalltalk
KANetworkTests >> testNodeLinking
	| node1 node2 link |
	node1 := KANetworkNode withAddress: #address1.
	node2 := KANetworkNode withAddress: #address2.
	link := KANetworkLink from: node1 to: node2.

	link attach.

	self assert: (node1 hasLinkTo: node2)
]]]

This test creates two nodes and a link; after telling the link to ''attach'' itself,  we check that it did so: the source node should confirm that it has an outgoing link to the destination node.
Note that the constructor could have registered the link with ==node1==, but we opted for a separate message ==attach== instead, because it's bad form to have a constructor change other objets; this way we can build links between arbitrary nodes and still have control of when the connection really becomes part of the network model.

Again, we need to define class of links:

[[[language=smalltalk
Object subclass: #KANetworkLink
	instanceVariableNames: 'source destination'
	classVariableNames: ''
	category: 'Kata-NetworkSimulator-Core'
]]]

A constructor that passes the two required parameters to an instance-side initialization message:

[[[language=smalltalk
KANetworkLink class >> from: sourceNode to: destinationNode
	^ self new
		initializeFrom: sourceNode to: destinationNode
]]]

The initialization method itself:

[[[language=smalltalk
KANetworkLink >> initializeFrom: sourceNode to: destinationNode
	source := sourceNode.
	destination := destinationNode.
]]]

Accessors:

[[[language=smalltalk
KANetworkLink >> source
	^ source
]]]

[[[language=smalltalk
KANetworkLink >> destination
    ^ destination
]]]

The ==attach== method of a link delegates to the source node (the link knows which node has to do something, and the node knows what to do precisely):

[[[language=smalltalk
KANetworkLink >> attach
	source attach: self
]]]

If each node knows about all its outgoing links, it means it has a collection of those; we therefore need to extend ==KANetworkNode==, first with an additional instance variable ==outgoingLinks==:

[[[language=smalltalk
Object subclass: #KANetworkNode
	instanceVariableNames: 'address outgoingLinks'
	classVariableNames: ''
	category: 'Kata-NetworkSimulator-Core'
]]]

This variable needs to be initialized properly:

[[[language=smalltalk
KANetworkNode >> initialize
	outgoingLinks := Set new.
]]]

We can then implement the ==attach:== method:

[[[language=smalltalk
KANetworkNode >> attach: anOutgoingLink
	outgoingLinks add: anOutgoingLink
]]]

And finally the testing method on instances of ==KANetworkNode==:

[[[language=smalltalk
KANetworkNode >> hasLinkTo: aNetworkNode
	^ outgoingLinks
		anySatisfy: [ :any | any destination == aNetworkNode ]
]]]


!!! Nodes can emit packets

The next big feature is that nodes should be able to emit packets.

[[[language=smalltalk
KANetworkTests >> testPacketEmission
	| src dest packet |
	src := KANetworkNode withAddress: 1.
	dest := KANetworkNode withAddress: 2.
	packet := KANetworkPacket from: src to: dest payload: #payload.

	src emit: packet.

	self assert: (src emissionQueue includes: packet).
	self assert: (dest receptionQueue includes: packet)
]]]

[[[language=smalltalk
KANetworkNode >> emit: aPacket
	emissionQueue add: aPacket
]]]

[[[language=smalltalk
KANetworkNode >> initializeAddress: aNetworkAddress
	outgoingLinks := Set new.
	emissionQueue := OrderedCollection new.
	address := aNetworkAddress
]]]

[[[language=smalltalk
emissionQueue
	^ emissionQueue
]]]

!!! A standalone node can transmit a packet to itself


!! first improvement: (something)
